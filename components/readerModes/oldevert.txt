import { FlatList, TouchableWithoutFeedback, View, Text, TouchableOpacity } from 'react-native';
import React, { useImperativeHandle, forwardRef, useCallback, useEffect, useRef, useState, useMemo } from 'react';
import ChapterPage from '../ChapterPage';
import { readMangaConfigData } from "../../app/screens/_mangaReader";
import * as backend from "../../app/screens/_mangaReader";

const VerticalReaderMode = forwardRef(({ chapterUrls, onTap, currentManga, onPageChange, initialScrollIndex }, ref) => {
  const [isLoading, setIsLoading] = useState(true);
  const [initialIndex, setInitialIndex] = useState(0);
  const [initialPageLoaded, setInitialPageLoaded] = useState(null);

  const flatRef = useRef(null);
  const pagesRef = useRef([]);
  const isInteracted = useRef(false);
  const thisCurrentPage = useRef(0);
  const pageLayout = useRef(Array(chapterUrls.length).fill(0));

  useImperativeHandle(ref, () => ({
    onReadmodeChange: () => {
      console.log("Read mode in ver");
    },
    retryFetch: () => {
      console.log("retrying to fetch page:", pagesRef.current[initialScrollIndex].getPageNum());
    }
  }));

  const onViewableItemsChanged = useCallback(({ viewableItems }) => {
    if (viewableItems.length > 0) {
      const currentViewableIndex = viewableItems[viewableItems.length - 1].index;
      onPageChange(currentViewableIndex);
      thisCurrentPage.current = currentViewableIndex;
      setIsLoading(initialIndex !== currentViewableIndex);
      flatRef.current.scrollToIndex({animated: true, index: initialScrollIndex})
    }
  }, [initialIndex, onPageChange]);

  const scrollToLast = async (pageNum, pageHeight) => {
    console.log("saving");
    pageLayout.current[pageNum] = pageHeight;
    await backend.saveItemLayout(currentManga.manga, currentManga.chapter, chapterUrls, pageLayout.current);
  };

  const fetchLastSavePage = async () => {
    setIsLoading(true);
    const lastSavePage = await readMangaConfigData(currentManga.manga, currentManga.chapter);
    setInitialIndex(lastSavePage ? lastSavePage.currentPage : 0);

    const savedPageLayout = await backend.readItemLayout(currentManga.manga, currentManga.chapter);
    console.log("saved page layout:", savedPageLayout);
    pageLayout.current = savedPageLayout;

    setIsLoading(false);
  };

  useEffect(() => {
    fetchLastSavePage();
  }, []);

  const renderItem = useCallback(({ item, index }) => (
    <TouchableWithoutFeedback onPress={onTap}>
      <View>
        <ChapterPage 
          ref={(page) => { pagesRef.current[index] = page; }} 
          currentManga={{ ...currentManga, chapterUrls }}
          pageUrl={item} 
          pageNum={index} 
          initialScrollIndex={initialScrollIndex}
          onLoad={scrollToLast}
        />
      </View>
    </TouchableWithoutFeedback>
  ), [initialScrollIndex, onTap]);

  const onScrollToIndexFailed = useCallback((info) => {
    setTimeout(() => {
      flatRef.current.scrollToIndex({ index: info.index, animated: true });
    }, 100);
  }, []);

  const getItemLayout = useCallback((data, index) => ({
    length: pageLayout.current[index] || 2000,
    offset: pageLayout.current.slice(0, index).reduce((a, c) => a + c, 0),
    index,
  }), []);

  const memoizedData = useMemo(() => chapterUrls, [chapterUrls]);

  return (
    <View>
      <View className="h-full w-full relative">
        <FlatList
          ref={flatRef}
          data={memoizedData}
          initialScrollIndex={initialScrollIndex}
          initialNumToRender={10}
          renderItem={renderItem}
          keyExtractor={(item) => item}
          onViewableItemsChanged={onViewableItemsChanged}
          onScrollToIndexFailed={onScrollToIndexFailed}
          onTouchMove={() => { isInteracted.current = true }}
          directionalLockEnabled
          disableVirtualization
          getItemLayout={getItemLayout}
        />
      </View>
      {initialPageLoaded && 
        <TouchableOpacity onPress={() => {
          setInitialPageLoaded(null);
        }}>
          <View className="absolute self-center bg-black-200 bottom-10 p-2 rounded-lg">
            <Text className="font-pregular text-white">Pick up where you left off</Text>
          </View>
        </TouchableOpacity>
      }
    </View>
  );
});

export default VerticalReaderMode;
